//
//  FollowersListVC.swift
//  GHFollowersProgrammaticUI
//
//  Created by Mustafa Fatih on 16/12/23.
//


import UIKit

class FollowersListVC: UIViewController {
    
    
    
    enum Section{case main}
    
    
    var username: String!
    var followers: [Follower] = []
    var filteredFollowers: [Follower] = []
    var page = 1
    var hasMoreFollowers = true
    var isSearching = false
    
    
    var collectionView: UICollectionView!
    var dataSource: UICollectionViewDiffableDataSource<Section, Follower>!
    //bu data source generic olarak 2 tane parametre aliyor ve hash functionslari kabul ediyor bu diffable data source. Burada verecegimiz 2 generic parametrenin hashable'i kabul etmesi gerekiyor. Ilk olarak collection View'imizin section'inin vermemiz gerekiyor. Bizim collection view sadece 1 section'a sahip. Onu ustte zaten enum olarak verdik. Bu arada enum'lar default olarak hashable dir zaten. Bu yuzden main adinda bir section'i enum'da olusturduk. 2. parametremiz follower object olacak. Follower objectimiz hashable degildir. Onu Model dizinine gidip decodable'in yanina hashable yazarak hashable yaptik.
    
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        configureCollectionView()
        configureViewController()
        configureSearchController()
        getFollowers(username: username, page: page)
        configureDataSource()
        
        //ViewdidLoad'in bu sekilde duzenli olmasi sana burada neler olup bittigine dair fikir veriyor. Kodun okunabilirligini arttiriyor. Sen de sonradan geldiginde anlayacaksin baskasi da... book table of contents gibi.
    
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        navigationController?.setNavigationBarHidden(false, animated: true)
        
        //viewWillAppear fonksiyonu i√ßinde, √ºst √ßubuƒüun g√∂r√ºn√ºrl√ºƒü√º ayarlanmƒ±≈ü.

    }
    
    
    func configureViewController(){
        navigationController?.isNavigationBarHidden = false
        view.backgroundColor = .systemBackground
        navigationController?.navigationBar.prefersLargeTitles = true // Buyuk olmasini istiyoruz.
        
        //configureViewController fonksiyonu i√ßinde, navigationController √∂zellikleri ayarlanarak g√∂r√ºn√ºm√ºn arka plan rengi belirlenmi≈ü.
        
    }
    
    func configureCollectionView(){
        collectionView = UICollectionView(frame: view.bounds, collectionViewLayout: UIHelper.createThreeColumnFlowLayout(in: view)) // Ilk olarak collectionViewimizi initialize etmemiz gerekiyor. Yani yerlestiriyoruz ekrana aslinda. burada frame olarak view.bounds verecegiz cunku collection view zaten tum ekrani kaplayacak.  Direkt view'i fill up doldur diyoruz.view.bounds ifadesi, koleksiyon g√∂r√ºn√ºm√ºn√ºn ba≈ülangƒ±√ß √ßer√ßevesini, i√ßinde bulunduƒüu √ºst d√ºzey g√∂r√ºn√ºm√ºn sƒ±nƒ±rlarƒ± ile aynƒ± boyut ve konumda olacak ≈üekilde belirler. Yani, koleksiyon g√∂r√ºn√ºm√º, i√ßinde bulunduƒüu g√∂r√ºn√ºm√ºn tamamƒ±nƒ± kaplar.
        
        
        //collectionViewLayout: UICollectionViewFlowLayout(): Bu, koleksiyon g√∂r√ºn√ºm√ºn√ºn d√ºzenini belirleyen bir √∂zelliktir. UICollectionViewFlowLayout, temelde bir ƒ±zgara d√ºzeni olu≈üturmak i√ßin kullanƒ±lan bir d√ºzen nesnesidir. Bu ifade, koleksiyon g√∂r√ºn√ºm√ºne bir ƒ±zgara d√ºzeni uygulayarak, veri √∂ƒüelerini belirli bir d√ºzen i√ßinde g√∂r√ºnt√ºlemesini saƒülar.
        //Daha sonra buraya gelip kendi custom Flow Layoutumuzu gosterecegiz. Daha sonra onu yazacagiz.
        
        
        view.addSubview(collectionView)
        collectionView.delegate = self
        collectionView.backgroundColor = .systemBackground
        collectionView.register(FollowerCell.self, forCellWithReuseIdentifier: FollowerCell.reuseID)
        
    //configureCollectionView fonksiyonu i√ßinde, UICollectionView √∂zellikleri ayarlanarak collectionView olu≈üturulmu≈ü ve g√∂r√ºn√ºme eklenmi≈ütir. Ayrƒ±ca, h√ºcre kaydƒ± da yapƒ±lmƒ±≈ü.
        
        
    }
    
    func configureSearchController(){
        let searchController = UISearchController()
        searchController.searchResultsUpdater = self
        searchController.searchBar.delegate = self
        searchController.searchBar.placeholder = "Search for a username"
        searchController.obscuresBackgroundDuringPresentation = false  //searche bastiginda alttaki collectionview'in kararmasini onluyor.
        navigationItem.hidesSearchBarWhenScrolling = false // bunu yazmazsan scroll yapmadikca search bar gozukmuyor.
        navigationItem.searchController = searchController
        
        
    }
    
   
    
    func getFollowers(username: String, page: Int){
        showLoadingView() //viewControllerin extensionu oldugu icin direkt bu sekilde yazabiliyoruz cunku tum viewcontrollerlar buna sahip...
        
        
        
        
        //Buraya sonradan usernmae ve page parametrelerini ekledik...
        
        
        //Gordugun gibi asagida network manager var. Network call'i burada yapiyoruz. network managerimiz asagida gordugun gibi self.followers = followers self.update() tarzinda strong reference lere sahip. Burada self dedigimiz tabi ki bizim bu classimiz yani follower list vc.. this could cause memory leak.. we would like to make this self a weak variable. Bunu bu sekilde [weak self] -> capture list deniyor buna galiba.. yazarak selfi weak yapabiliyoruz. bu durum selflerin optional olma ihtiyacina sebep oluyor cok dogal olarak. Cunku weak oldugu icin gelmeyebilir vibe 'i olusuyor. selflerin oraya ? koymamak icin
        NetworkManager.sharedd.getFollowers(for: username, page: page) { [weak self] result in
            
            
            
            //swift 4.2 de tanitilan su kod satirini buraya koyabilirsin ancak ben koymak istemiyorum. guard let self = self else {return} seklinde yazabilirsin.
            
            //evet suanda bu kisimda isimiz kalmadi. Ileride proje icinde baska yerlerde de network call yapacagiz. orada  bu arc fikrini reinforce edecegiz iyice.. 
            
            switch result {
            case.success(let followers):
                
                guard let self = self else {return}
                
                // #warning("Call dismis here") //bu bir warning bu seilde yazilabiliyor sanirim
                self.dismissLoadingView()

                if followers.count < 100 { self.hasMoreFollowers = false} //Burada direkt false yapiyoruz ki scrol yapmasin...
                self.followers.append(contentsOf: followers) //Buradaki self.followers yukarida olusturdugumuz dizi...
               
                
                if self.followers.isEmpty {
                    let message = "This user doesn't have any followers. Go follow them üòÄ."
                    DispatchQueue.main.async{
                        self.ShowEmptyStateView(message: message, view: self.view) //closureda oldugumuz icin self koyacagiz mecbur. Zaten extension oldugu icin geliyor direkt.
                        return
                    }
                }
                
                
                self.updateData(followers: self.followers)
                
            case.failure(let error):
                self?.presenatGFAlertOnMainThread(title: "Bad stuff Happend", message: error.rawValue , buttonTitle: "OK")
                
            }
            //getFollowers fonksiyonu i√ßinde, aƒü √ßaƒürƒ±sƒ± yapƒ±larak takip√ßi bilgileri alƒ±nmƒ±≈ü.

        }
    }
    
    
    
    func configureDataSource(){
        dataSource = UICollectionViewDiffableDataSource<Section, Follower>(collectionView: collectionView, cellProvider: { (collectionView, indexPath, follower) -> UICollectionViewCell? in
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: FollowerCell.reuseID, for: indexPath) as! FollowerCell //burada as yapiyoruz cunku as den oncesi regular default cell dir. bizim bunu follower cell olarak cast etmemiz gerekiyor.
            cell.set(follower: follower) //followerCell swift dosyasindan set fonksiyonunu cagirdik ve set ettik. Yani cell'imizi burada aslinda follower cell dosyasina follower'i gondererek baslatmis olduk...
            //bu cell 'i su sekild  e configure edenlerde var. Bu cell bizim olusturdugumuz cell swift dosyasini represent eden cell zaten anladigim kadariyla ve oraya direkt ulasiyor.
//            cell.avatarImage
//            cell.usernameLabel = ......   seklinde configure edenlerde var. ancak biz tek satirda hallediyoruz isi..
            
            
            return cell
            
            
            //aslinda burada ilk olarak resuable bir cell olusturduk, daha sonra o cell'i configure ettik ve en sonda dondurduk.
            //configureDataSource fonksiyonu i√ßinde, UICollectionViewDiffableDataSource olu≈üturulmu≈ü ve cellProvider kullanƒ±larak h√ºcreler i√ßin veri saƒülanmƒ±≈ü.
        } )
        
        
    }
    
    
    func updateData(followers: [Follower]){
        var snapshot = NSDiffableDataSourceSnapshot<Section, Follower>()
        snapshot.appendSections([.main])
        snapshot.appendItems(followers)
        
        DispatchQueue.main.async {
            
            self.dataSource.apply(snapshot, animatingDifferences: true)
            
        }
     
        //updateData fonksiyonu i√ßinde, NSDiffableDataSourceSnapshot kullanƒ±larak veriler g√ºncellenmi≈ü ve g√∂r√ºn√ºme yansƒ±tƒ±lmƒ±≈ü.
        
        
        
    }
    
    
  
}


extension FollowersListVC: UICollectionViewDelegate {
    
    func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
        
        let offsetY = scrollView.contentOffset.y // Bu satƒ±r, kullanƒ±cƒ±nƒ±n ≈üu anda g√∂r√ºnt√ºlenen i√ßeriƒüin en √ºst√ºnden ne kadar uzakta olduƒüunu belirten bir deƒüi≈ükeni tanƒ±mlar.
        
        
        let contentHeight = scrollView.contentSize.height //Bu satƒ±r, koleksiyon g√∂r√ºn√ºm√ºndeki toplam i√ßeriƒüin y√ºksekliƒüini temsil eden bir deƒüi≈ükeni tanƒ±mlar.
        
        
        let height = scrollView.frame.size.height //Bu satƒ±r, koleksiyon g√∂r√ºn√ºm√ºn√ºn g√∂r√ºnen y√ºksekliƒüini temsil eden bir deƒüi≈ükeni tanƒ±mlar.
        
        
        //Bu if ko≈üulu, kullanƒ±cƒ±nƒ±n sayfanƒ±n sonuna gelip gelmediƒüini kontrol eder. Eƒüer kullanƒ±cƒ± sayfanƒ±n sonuna geldiyse, i√ßeriƒüin daha fazla y√ºklenip y√ºklenmediƒüini kontrol etmek √ºzere bir dizi ko≈üul eklenir. Mesela content height demek toplam user'in yuksekligi... Mesela 2000 tane var. Hepsini yuksekligi demek. Ornegin 100 metre olsun heighte 50 olsun yani o anki user icin yukseklik
        if offsetY > contentHeight - height {
            
            guard hasMoreFollowers else {return}//Bu satƒ±r, daha fazla takip√ßi olup olmadƒ±ƒüƒ±nƒ± kontrol eder. Eƒüer daha fazla takip√ßi yoksa, fonksiyonu terk eder. Cunku eger adamin mesela 10 takipcisi varsa daha fazla follower getirmene gerek yoktur... O yuzden bunu kontrol etmen gerekiyor. Yukarida getFollowers fonksiyonunda buna count yaparak bakiyoruz zaten.
            
            page += 1 // Eƒüer daha fazla takip√ßi varsa, sayfa numarasƒ±nƒ± bir artƒ±rarak bir sonraki sayfayƒ± almak i√ßin hazƒ±rlƒ±k yapƒ±lƒ±r.
            
            
            //Burada page number'i counter olarak kullaniyoruz aslinda.  Page sayisini ustte 1 arttirdik ve buraya parametre olarak gonderdik.. Zaten en ustte de page variableimizi olusturduk...Zaten ilk calistirildiginda page 1 olarak calisacak scroll edip en alta geldigimizce 2 olacak bu fonksiyon icerisinde.
            getFollowers(username: username, page: page) // Bu satƒ±r, getFollowers fonksiyonunu √ßaƒüƒ±rarak belirtilen kullanƒ±cƒ± adƒ± ve sayfa numarasƒ±yla yeni takip√ßileri almayƒ± saƒülar
        }
        
     
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        /*
        if( isSearching == false){
            let follower = followers[indexPath.item] //This is the what is tapped
        }
        else{
            let follower = filteredFollowers[indexPath.item]
        }
        Bunu bu sekilde yapmak yerine daha pratik bir yol var 2 satirda isi cozuyoruz... W ? T: F yontemi yani What ? True or False demek.
         
         Eƒüer isSearching deƒüi≈ükeni true ise, o zaman activeArray deƒüi≈ükeni filteredFollowers dizisinin deƒüerini alƒ±r.
         Eƒüer isSearching deƒüi≈ükeni false ise, o zaman activeArray deƒüi≈ükeni followers dizisinin deƒüerini alƒ±r.
         */
        
        let activeArray = isSearching ? filteredFollowers : followers
        let followerUser = activeArray[indexPath.item]
        
        
        
        let destinationVC = UserInfoVC()
        
        destinationVC.username = followerUser.login
        
        let navigationController = UINavigationController(rootViewController: destinationVC)
        present(navigationController, animated: true)
        
        
        
    }
   
    
   
}

extension FollowersListVC: UISearchResultsUpdating,UISearchBarDelegate {
    func updateSearchResults(for searchController: UISearchController) {
        //Burada searchbardaki yazi degistikce search'in update olmasinin ayarlayacagiz. burada arrayimizi filterlayacagiz ve collectionViewimizi ona gore update edecegiz. Ilk olarak searchController'in searchbarinda text oldugundan emin olmaliyiz.
        
        //2. kisminda empty olup olmadigina da bakiyoruz. Iste empty olursa search result'i update etmemis olacagiz. Direkt return ile cikiyoruz.
        guard let filter = searchController.searchBar.text, !filter.isEmpty else {return}
        
        //burada filter olmus yeni bir array'e ihtiyacimiz var. Cunku collection view'da her seferinde onu gosterecegiz. Bu sekilde update edilmis olacak.
        //CollectionViewda da zaten array of followers var yani. Yani searchBar da yazdigimiz texte gore filter olacak mevcut array her seferinde.
        //Bunun icin en ustte filteredArray follower olusturuyourz.
        
        isSearching  = true
        filteredFollowers = followers.filter {
            $0.login.lowercased().contains(filter.lowercased())} //buradaki filter'in olayi ile ilgili sean allen'in videosu var. Bu rabbit hole'a girmeyelim simdi.
    updateData(followers: filteredFollowers)
        
        
    }
    
    
    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
        isSearching = false //Bu arada isSearching.toggle() diye bir sey var direkt boolena'i flip ediyormus galiba...
        updateData(followers: followers)
    }
    
    
}


